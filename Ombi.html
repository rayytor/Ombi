<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ombi</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
html, body {
  margin:0; padding:0; height:100%;
  display:flex; justify-content:center; align-items:center;
  background:#111; font-family:Verdana, sans-serif; color:white;
  overflow:hidden;
  touch-action: none; /* Prevent unwanted browser scrolling/zooming */
}
#game-container { position: relative; }
canvas { display:block; border:2px solid #444; }

/* Control Buttons (Desktop/Mouse) */
#pauseBtn {
  position:absolute; top:10px; right:10px;
  background:rgba(0,0,0,0.5); border:none; color:white;
  font-size:24px; padding:8px 12px; cursor:pointer;
  border-radius:5px; z-index:10;
}
#pauseBtn:hover { background: rgba(255,255,255,0.2); }

#mobileToggleBtn { /* New button for toggling mobile view */
  position:absolute; top:10px; right:65px;
  background:rgba(0,0,0,0.5); border:none; color:white;
  font-size:14px; padding:8px 12px; cursor:pointer;
  border-radius:5px; z-index:10;
}
#mobileToggleBtn:hover { background: rgba(255,255,255,0.2); }


#restartBtn {
  position:absolute;
  background:rgba(0,0,0,0.6);
  color:white; border:none; border-radius:8px;
  padding:10px 20px; font-size:22px; cursor:pointer; z-index:20;
}
#restartBtn:hover { background: rgba(255,255,255,0.2); }

/* --- Touchscreen Controls --- */
.touch-control {
  position: absolute;
  z-index: 50;
  display: flex;
  justify-content: center;
  align-items: center;
}

/* Joystick (Movement) */
#joystick-container {
  bottom: 20px;
  left: 20px;
  width: 120px;
  height: 120px;
  border-radius: 50%;
  background: rgba(0, 0, 0, 0.4);
}
#joystick-handle {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.6);
  transform: translate(0, 0); /* Moved by touch */
  transition: transform 0.1s ease-out; /* Smooth reset */
}

/* Fire/Action Button */
#fire-button {
  bottom: 40px;
  right: 40px;
  width: 80px;
  height: 80px;
  border-radius: 50%;
  background: crimson;
  border: 4px solid #fff;
  font-size: 30px;
  color: white;
  opacity: 0.8;
}
#fire-button:active { opacity: 1.0; background: red; } /* Feedback on touch */

/* Weapon Switch/Reload Buttons */
#weapon-switch-btn {
  top: 10px;
  left: 10px;
  width: 80px;
  height: 40px;
  background: rgba(0,0,0,0.5);
  border: none;
  color: white;
  font-size: 18px;
  border-radius: 5px;
  cursor: pointer;
  padding: 5px;
}
#weapon-switch-btn:active { background: rgba(255,255,255,0.2); }

#reload-btn {
  top: 60px;
  left: 10px;
  width: 80px;
  height: 40px;
  background: rgba(0,0,0,0.5);
  border: none;
  color: white;
  font-size: 16px;
  border-radius: 5px;
  cursor: pointer;
  padding: 5px;
}
#reload-btn:active { background: rgba(255,255,255,0.2); }

#action-btn {
  bottom: 40px;
  right: 140px;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: #333;
  border: 2px solid #fff;
  font-size: 20px;
  color: white;
  opacity: 0.8;
  display: none; /* Only show when near a crate */
}
#action-btn:active { background: #555; }

/* Initial state: Touch controls are hidden on large screens
  The .mobile-mode class will be toggled by the new button to override this. 
*/
#joystick-container, #fire-button, #weapon-switch-btn, #reload-btn, #action-btn { display: none; }

/* Show touch controls on small screens OR when the 'mobile-mode' class is active */
@media (max-width: 820px) {
  #joystick-container, #fire-button, #weapon-switch-btn, #reload-btn { display: flex; }
  /* Action button visibility is handled in JS based on proximity, but needs to be 'flex' on mobile */
  #action-btn { display: flex; opacity: 0; } /* Set initial opacity to 0, JS will control visibility/opacity */
}

/* Override for manual toggle: If the container has 'mobile-mode', show the controls */
.mobile-mode #joystick-container,
.mobile-mode #fire-button,
.mobile-mode #weapon-switch-btn,
.mobile-mode #reload-btn { 
    display: flex; 
}
.mobile-mode #action-btn {
  /* Action button still relies on JS visibility but needs 'flex' when toggled */
  display: flex;
}
</style>
</head>
<body>
<div id="game-container">
  <canvas id="game" width="800" height="600" aria-label="Game canvas" tabindex="0"></canvas>
  <button id="mobileToggleBtn">Mobile On</button> <button id="pauseBtn">⏸️</button>

  <div id="joystick-container" class="touch-control">
    <div id="joystick-handle"></div>
  </div>
  <button id="fire-button" class="touch-control">FIRE</button>
  <button id="weapon-switch-btn" class="touch-control">Switch</button>
  <button id="reload-btn" class="touch-control">Reload</button>
  <button id="action-btn" class="touch-control">E</button>

</div>
<script>
const CONFIG = {
  VIEW_W: 800,
  VIEW_H: 600,
  MAP_W: 2200,
  MAP_H: 1800,
  ZONE_SHRINK_RATE: 0.01,
  ENEMY_SPAWN_INTERVAL: 3000,
  GRASS_BLADE_COUNT: 70,
  GRASS_LENGTH_MIN: 10,
  GRASS_LENGTH_MAX: 20,
  PLAYER_START: { x: 1100, y: 900, size: 20, color: 'teal', speed: 3, health: 100 },
  ZONE_START: { x: 1100, y: 900, radius: 900 },
  ENEMY_HIT_ANIMATION_TIME: 1000,
  ENEMY_HIT_DAMAGE: 10,
  CRATE_SIZE: 24,
  CRATE_AMMO: {
    rifle: 20,
    pistol: 6
  },
  WEAPONS: [
    { name:'Pistol', damage:40, fireRate:400, automatic:false, gunLength:15, gunWidth:5, color:'#999', recoil:2, type:'gun', magSize:6, ammo:6, reloadTime:1500, bulletSpeed:7, maxAmmo:30, totalAmmo:30 },
    { name:'Rifle',  damage:10, fireRate:120, automatic:true,  gunLength:25, gunWidth:5, color:'#8B4513', recoil:1, type:'gun', magSize:20, ammo:20, reloadTime:2500, bulletSpeed:9, maxAmmo:100, totalAmmo:100 },
    { name:'Stick', damage:7, fireRate:300, automatic:false, stickLength:28, stickWidth:6, color:'#d2b48c', type:'melee', knockback:32 }
  ]
};

function clamp(val, min, max) { return Math.max(min, Math.min(val, max)); }

class Player {
  constructor(cfg) { Object.assign(this, cfg); }
  reset() { Object.assign(this, CONFIG.PLAYER_START); }
}

class Enemy {
  constructor(x, y, size, color, speed, health) {
    Object.assign(this, { 
      x, y, size, color, speed, health, maxHealth: health, 
      dx: 0, dy: 0, vx: 0, vy: 0,
      hitting: false,
      hitAnimStart: 0
    });
    this.hidden = false;
  }
}
class Bullet {
  constructor(x, y, dx, dy, damage, angle) {
    Object.assign(this, { x, y, dx, dy, damage, angle, visible: true });
  }
}
class MuzzleFlash {
  constructor(x, y, angle, size) {
    Object.assign(this, { x, y, angle, size, created: Date.now() });
  }
}
class GrassBlade {
  constructor(x, y, length, angle) {
    Object.assign(this, { x, y, length, angle });
  }
}
class Crate {
  constructor(x, y, type) {
    Object.assign(this, { x, y, size: CONFIG.CRATE_SIZE, type, opened: false, hidden: false });
  }
}

class Game {
  constructor(canvas, ctx) {
    this.canvas = canvas;
    this.ctx = ctx;
    this.mapW = CONFIG.MAP_W;
    this.mapH = CONFIG.MAP_H;
    this.viewW = CONFIG.VIEW_W;
    this.viewH = CONFIG.VIEW_H;
    this.zone = { ...CONFIG.ZONE_START };
    this.player = new Player(CONFIG.PLAYER_START);
    this.kills = 0;
    this.weapons = JSON.parse(JSON.stringify(CONFIG.WEAPONS));
    this.currentWeapon = 0;
    this.lastShotTime = 0;
    this.reloading = false;
    this.reloadStartTime = 0;
    this.reloadRemaining = 0;
    this.pointerX = this.viewW / 2;
    this.pointerY = this.viewH / 2;
    this.bullets = [];
    this.muzzleFlashes = [];
    this.enemies = [];
    this.grassBlades = [];
    this.crates = [];
    this.lastZoneDamage = Date.now();
    this.spawnTimer = null;
    this.keys = {};
    this.mouseDown = false;
    this.paused = false;
    this.running = false;
    this.lastFrameTime = performance.now();
    this.viewX = 0;
    this.viewY = 0;
    this.outOfAmmoState = { pistol: false, rifle: false };
    this.openCrateRequested = false;

    // --- Touch/Mobile Control State ---
    this.touchMoveActive = false;
    this.touchMoveStart = { x: 0, y: 0 };
    this.touchMoveCurrent = { x: 0, y: 0 };
    this.touchFireActive = false; // Used for both mouse and touch fire on mobile controls
    this.joystickHandle = document.getElementById('joystick-handle');
    this.joystickContainer = document.getElementById('joystick-container');
    this.actionBtn = document.getElementById('action-btn');
    this.fireBtn = document.getElementById('fire-button');
    this.isDesktopClickActive = false; // NEW: Track if a mouse click is holding down a mobile control
  }

  start() {
    this.running = true;
    this.paused = false;
    this.zone = { ...CONFIG.ZONE_START };
    this.player.reset();
    this.kills = 0;
    this.weapons = JSON.parse(JSON.stringify(CONFIG.WEAPONS));
    this.weapons[0].totalAmmo = this.weapons[0].maxAmmo = 30;
    this.weapons[1].totalAmmo = this.weapons[1].maxAmmo = 100;
    this.weapons[0].ammo = this.weapons[0].magSize;
    this.weapons[1].ammo = this.weapons[1].magSize;
    this.currentWeapon = 0;
    this.lastShotTime = 0;
    this.reloading = false;
    this.reloadStartTime = 0;
    this.reloadRemaining = 0;
    this.pointerX = this.viewW / 2;
    this.pointerY = this.viewH / 2;
    this.bullets = [];
    this.muzzleFlashes = [];
    this.enemies = [];
    this.crates = [];
    this.grassBlades = [];
    this.lastZoneDamage = Date.now();
    this.keys = {};
    this.mouseDown = false; // Desktop/Canvas fire
    this.isDesktopClickActive = false; // Mobile control mouse emulation
    this.outOfAmmoState = { pistol: false, rifle: false };
    this.openCrateRequested = false;
    this.touchMoveActive = false;
    this.touchFireActive = false;
    this.joystickHandle.style.transform = `translate(0px, 0px)`;
    clearInterval(this.spawnTimer);
    this.spawnTimer = setInterval(() => this.spawnEnemy(), CONFIG.ENEMY_SPAWN_INTERVAL);
    this.removeRestartBtn();
    this.lastFrameTime = performance.now();
    this.gameLoop();
  }

  pause() {
    this.paused = true;
    clearInterval(this.spawnTimer);
  }

  resume() {
    if (!this.running) return;
    this.paused = false;
    this.lastZoneDamage = Date.now();
    clearInterval(this.spawnTimer);
    this.spawnTimer = setInterval(() => this.spawnEnemy(), CONFIG.ENEMY_SPAWN_INTERVAL);
    this.lastFrameTime = performance.now();
    this.gameLoop();
  }

  endGame() {
    this.running = false;
    clearInterval(this.spawnTimer);
    this.player.health = 0;
    this.showRestartBtn();
  }

  showRestartBtn() {
    this.removeRestartBtn();
    const btn = document.createElement("button");
    btn.id = "restartBtn";
    btn.textContent = "Restart";
    btn.style.left = (this.viewW/2-60)+"px";
    btn.style.top = (this.viewH/2+50)+"px";
    document.getElementById("game-container").appendChild(btn);
    btn.addEventListener("click", () => this.start());
  }

  removeRestartBtn() {
    const btn = document.getElementById("restartBtn");
    if (btn) btn.remove();
  }

  spawnEnemy() {
    if (this.paused || !this.running) return;
    let angle = Math.random() * Math.PI * 2;
    let rad = Math.random() * (this.zone.radius-30);
    let x = this.zone.x + Math.cos(angle) * rad;
    let y = this.zone.y + Math.sin(angle) * rad;
    x = clamp(x, 30, this.mapW-30);
    y = clamp(y, 30, this.mapH-30);
    const baseHealth = 50, baseSpeed = 0.6, size = 20;
    const health = baseHealth + this.kills * 2;
    const speed = baseSpeed + Math.random()*0.4 + this.kills * 0.05;
    this.enemies.push(new Enemy(x, y, size, 'crimson', speed, health));
  }

  handleInput() {
    // Keyboard input
    if (this.keys['w']) this.player.y -= this.player.speed;
    if (this.keys['s']) this.player.y += this.player.speed;
    if (this.keys['a']) this.player.x -= this.player.speed;
    if (this.keys['d']) this.player.x += this.player.speed;

    // Joystick input (Touch or Mouse emulation)
    if (this.touchMoveActive) {
      const dx = this.touchMoveCurrent.x - this.touchMoveStart.x;
      const dy = this.touchMoveCurrent.y - this.touchMoveStart.y;
      const dist = Math.hypot(dx, dy);
      const maxDist = 40;
      
      if (dist > 5) { // Deadzone
        const angle = Math.atan2(dy, dx);
        const effectiveSpeed = this.player.speed * Math.min(1, dist / maxDist);
        this.player.x += Math.cos(angle) * effectiveSpeed;
        this.player.y += Math.sin(angle) * effectiveSpeed;
      }
    }

    this.player.x = clamp(this.player.x, this.player.size/2, this.mapW-this.player.size/2);
    this.player.y = clamp(this.player.y, this.player.size/2, this.mapH-this.player.size/2);
  }

  spawnCrates(type) {
    for (let i=0; i<5; ++i) {
      let x, y, tries = 0;
      do {
        let angle = Math.random() * Math.PI * 2;
        let rad = Math.random() * (this.zone.radius - CONFIG.CRATE_SIZE*2);
        x = this.zone.x + Math.cos(angle) * rad;
        y = this.zone.y + Math.sin(angle) * rad;
        x = clamp(x, CONFIG.CRATE_SIZE, this.mapW-CONFIG.CRATE_SIZE);
        y = clamp(y, CONFIG.CRATE_SIZE, this.mapH-CONFIG.CRATE_SIZE);
        tries++;
      } while (
        x > this.viewX-40 && x < this.viewX+this.viewW+40 &&
        y > this.viewY-40 && y < this.viewY+this.viewH+40 &&
        tries < 50
      );
      this.crates.push(new Crate(x, y, type));
    }
  }

  attack() {
    if (this.paused || this.reloading || !this.running) return;
    const now = Date.now();
    const weapon = this.weapons[this.currentWeapon];
    if (now - this.lastShotTime < weapon.fireRate) return;
    if (weapon.type === 'gun' && weapon.ammo <= 0) return;
    this.lastShotTime = now;

    const worldPointerX = this.viewX + this.pointerX;
    const worldPointerY = this.viewY + this.pointerY;
    const angle = Math.atan2(worldPointerY - this.player.y, worldPointerX - this.player.x);

    if (weapon.type === 'gun') {
      if (weapon.ammo > 0) {
        const barrelX = this.player.x + Math.cos(angle) * (this.player.size/2 + weapon.gunLength);
        const barrelY = this.player.y + Math.sin(angle) * (this.player.size/2 + weapon.gunLength);
        this.bullets.push(new Bullet(barrelX, barrelY, Math.cos(angle)*weapon.bulletSpeed, Math.sin(angle)*weapon.bulletSpeed, weapon.damage, angle));
        this.player.x -= Math.cos(angle) * weapon.recoil;
        this.player.y -= Math.sin(angle) * weapon.recoil;
        this.muzzleFlashes.push(new MuzzleFlash(barrelX, barrelY, angle, 12));
        weapon.ammo--;
        if (weapon.ammo <= 0) {
          if (weapon.totalAmmo > 0) {
            this.reloading = true;
            this.reloadRemaining = weapon.reloadTime;
            this.reloadStartTime = Date.now();
          } else {
            if (weapon.name === 'Pistol' && !this.outOfAmmoState.pistol) {
              this.outOfAmmoState.pistol = true;
              this.spawnCrates('pistol');
            }
            if (weapon.name === 'Rifle' && !this.outOfAmmoState.rifle) {
              this.outOfAmmoState.rifle = true;
              this.spawnCrates('rifle');
            }
          }
        }
      }
    }
  }

  handleAuto() {
    // Fire if: Mouse down on canvas OR Mobile fire button is active (touch OR mouse emulation)
    const isFiring = this.mouseDown || this.touchFireActive;
    if (isFiring && this.weapons[this.currentWeapon].automatic && !this.paused && !this.reloading && this.running) {
      this.attack();
    }
  }

  update(delta) {
    if (!this.running || this.paused) return;

    this.viewX = clamp(this.player.x - this.viewW/2, 0, this.mapW - this.viewW);
    this.viewY = clamp(this.player.y - this.viewH/2, 0, this.mapH - this.viewH);

    if (this.reloading) {
      const weapon = this.weapons[this.currentWeapon];
      const now = Date.now();
      this.reloadRemaining -= now - this.reloadStartTime;
      this.reloadStartTime = now;
      if (this.reloadRemaining <= 0) {
        let needed = weapon.magSize - weapon.ammo;
        let take = Math.min(needed, weapon.totalAmmo);
        weapon.ammo += take;
        weapon.totalAmmo -= take;
        this.reloading = false;
        this.reloadRemaining = 0;
        if (weapon.totalAmmo <= 0) {
          if (weapon.name === 'Pistol' && !this.outOfAmmoState.pistol) {
            this.outOfAmmoState.pistol = true;
            this.spawnCrates('pistol');
          }
          if (weapon.name === 'Rifle' && !this.outOfAmmoState.rifle) {
            this.outOfAmmoState.rifle = true;
            this.spawnCrates('rifle');
          }
        }
      }
    }
    this.handleInput();
    this.handleAuto();

    let crateProximity = false;
    // Bullets
    for (let i = this.bullets.length-1; i >= 0; i--) {
      let b = this.bullets[i];
      b.x += b.dx;
      b.y += b.dy;
      b.visible = true;
      if (b.x < 0 || b.x > this.mapW || b.y < 0 || b.y > this.mapH) {
        this.bullets.splice(i,1);
        continue;
      }
      for (let j = this.enemies.length-1; j >= 0; j--) {
        let e = this.enemies[j];
        if (e.hidden) continue;
        if (Math.hypot(b.x-e.x, b.y-e.y) < e.size/2) {
          e.health -= b.damage;
          this.bullets.splice(i,1);
          break;
        }
      }
    }

    // Crate pickup (open with E/Action button while touching)
    for (let i = 0; i < this.crates.length; i++) {
      let crate = this.crates[i];
      crate.hidden = (
        crate.x < this.viewX - crate.size ||
        crate.x > this.viewX + this.viewW + crate.size ||
        crate.y < this.viewY - crate.size ||
        crate.y > this.viewY + this.viewH + crate.size
      );
      
      const isTouching = Math.hypot(this.player.x-crate.x, this.player.y-crate.y) < this.player.size/2 + crate.size/2;

      // Show action button on mobile if near a crate
      if (isTouching && !crate.opened) {
        crateProximity = true;
      }

      if (!crate.opened && !crate.hidden && isTouching && this.openCrateRequested) {
        crate.opened = true;
        let weaponIndex = -1;
        if (crate.type === 'rifle') { weaponIndex = 1; this.outOfAmmoState.rifle = false; }
        if (crate.type === 'pistol') { weaponIndex = 0; this.outOfAmmoState.pistol = false; }
        
        if (weaponIndex !== -1) {
          let weapon = this.weapons[weaponIndex];
          weapon.totalAmmo += CONFIG.CRATE_AMMO[crate.type];
          if (weapon.ammo === 0 && !this.reloading) {
            this.reloading = true;
            this.reloadRemaining = weapon.reloadTime;
            this.reloadStartTime = Date.now();
          }
        }
      }
    }
    this.openCrateRequested = false;

    // Control visibility of action button
    // This logic only applies if the game is in a mobile-control state (small screen OR toggle active)
    const isMobileControlEnabled = window.innerWidth <= 820 || document.getElementById('game-container').classList.contains('mobile-mode');

    if (isMobileControlEnabled) {
      if (crateProximity) {
        this.actionBtn.style.display = 'flex';
        this.actionBtn.style.opacity = '0.8';
      } else {
        this.actionBtn.style.opacity = '0';
        // Use a timeout to hide the element completely after a delay, prevents flicker
        if (parseFloat(this.actionBtn.style.opacity) === 0) {
          setTimeout(() => { if (parseFloat(this.actionBtn.style.opacity) === 0) this.actionBtn.style.display = 'none'; }, 200);
        }
      }
    } else {
       this.actionBtn.style.display = 'none';
    }


    // Enemy logic and collisions
    for (let i = 0; i < this.enemies.length; i++) {
      let e = this.enemies[i];
      e.vx *= 0.86;
      e.vy *= 0.86;
      const dx = this.player.x - e.x, dy = this.player.y - e.y;
      const dist = Math.hypot(dx, dy);
      if (dist > 0) {
        let approach = (dist > 50) ? 1 : 0.4;
        let speed = e.speed * approach;
        e.vx += (dx/dist) * speed * 0.12;
        e.vy += (dy/dist) * speed * 0.12;
      }

      // Collide with other enemies (bouncy)
      for (let j = i+1; j < this.enemies.length; j++) {
        let e2 = this.enemies[j];
        let ddx = e2.x - e.x;
        let ddy = e2.y - e.y;
        let ddist = Math.hypot(ddx, ddy);
        let minDist = (e.size/2 + e2.size/2);
        if (ddist < minDist && ddist > 0) {
          let overlap = minDist - ddist;
          let pushX = (ddx/ddist)*overlap/2;
          let pushY = (ddy/ddist)*overlap/2;
          e.x -= pushX;
          e.y -= pushY;
          e2.x += pushX;
          e2.y += pushY;
        }
      }

      // Collide with crates (bouncy)
      for (let c = 0; c < this.crates.length; c++) {
        let crate = this.crates[c];
        if (crate.opened) continue;
        let ddx = crate.x - e.x;
        let ddy = crate.y - e.y;
        let ddist = Math.hypot(ddx, ddy);
        let minDist = (e.size/2 + crate.size/2);
        if (ddist < minDist && ddist > 0) {
          let overlap = minDist - ddist;
          let pushX = (ddx/ddist)*overlap/2;
          let pushY = (ddy/ddist)*overlap/2;
          e.x -= pushX;
          e.y -= pushY;
          crate.x += pushX;
          crate.y += pushY;
        }
      }

      e.x += e.vx;
      e.y += e.vy;

      // Player collision
      let minDistPlayer = (this.player.size/2 + e.size/2);
      if (dist < minDistPlayer) {
        if (!e.hitting) {
          e.hitting = true;
          e.hitAnimStart = Date.now();
        }
        let overlap = minDistPlayer - dist;
        if (dist > 0) {
          let pushX = (dx/dist) * overlap * 1.8;
          let pushY = (dy/dist) * overlap * 1.8;
          e.vx -= pushX * 0.06;
          e.vy -= pushY * 0.06;
          this.player.x += pushX * 0.013;
          this.player.y += pushY * 0.013;
        }
        if (Date.now() - e.hitAnimStart > CONFIG.ENEMY_HIT_ANIMATION_TIME) {
          this.player.health -= CONFIG.ENEMY_HIT_DAMAGE;
          e.hitAnimStart = Date.now();
          if (this.player.health <= 0) this.endGame();
        }
      } else {
        e.hitting = false;
      }

      // Melee stick: push enemies that touch it (smaller stick)
      if (this.weapons[this.currentWeapon].type === 'melee') {
        const stick = this.weapons[2];
        let stickAngle = Math.atan2(this.pointerY + this.viewY - this.player.y,this.pointerX + this.viewX - this.player.x);
        let stickStartX = this.player.x + Math.cos(stickAngle) * (this.player.size/2);
        let stickStartY = this.player.y + Math.sin(stickAngle) * (this.player.size/2);
        let stickEndX = this.player.x + Math.cos(stickAngle) * (this.player.size/2 + stick.stickLength);
        let stickEndY = this.player.y + Math.sin(stickAngle) * (this.player.size/2 + stick.stickLength);
        let ex = e.x, ey = e.y;
        let dxl = stickEndX - stickStartX;
        let dyl = stickEndY - stickStartY;
        let len = Math.hypot(dxl, dyl);
        let t = ((ex - stickStartX)*dxl + (ey - stickStartY)*dyl) / (len*len);
        t = clamp(t, 0, 1);
        let closestX = stickStartX + dxl * t;
        let closestY = stickStartY + dyl * t;
        let stickDist = Math.hypot(ex - closestX, ey - closestY);
        if (stickDist < e.size/2 + stick.stickWidth/2) {
          let pushAngle = Math.atan2(ex - closestX, ey - closestY);
          e.vx += Math.sin(pushAngle) * stick.knockback * 0.09;
          e.vy += Math.cos(pushAngle) * stick.knockback * 0.09;
          e.health -= stick.damage * 0.13;
        }
      }

      e.hidden = (
        e.x < this.viewX - e.size ||
        e.x > this.viewX + this.viewW + e.size ||
        e.y < this.viewY - e.size ||
        e.y > this.viewY + this.viewH + e.size
      );

      if (e.health <= 0) {
        this.enemies.splice(i,1);
        this.kills++;
        i--;
      }
    }

    // Crate <-> crate collision
    for (let i = 0; i < this.crates.length; i++) {
      let crateA = this.crates[i];
      if (crateA.opened) continue;
      for (let j = i+1; j < this.crates.length; j++) {
        let crateB = this.crates[j];
        if (crateB.opened) continue;
        let dx = crateB.x - crateA.x;
        let dy = crateB.y - crateA.y;
        let dist = Math.hypot(dx, dy);
        let minDist = crateA.size/2 + crateB.size/2;
        if (dist < minDist && dist > 0) {
          let overlap = minDist - dist;
          let pushX = (dx/dist)*overlap/2;
          let pushY = (dy/dist)*overlap/2;
          crateA.x -= pushX;
          crateA.y -= pushY;
          crateB.x += pushX;
          crateB.y += pushY;
        }
      }
    }
    // Crate <-> enemy collision (already handled above)

    this.zone.radius -= CONFIG.ZONE_SHRINK_RATE;
    const distToZone = Math.hypot(this.player.x-this.zone.x, this.player.y-this.zone.y);
    if (distToZone > this.zone.radius) {
      const now = Date.now();
      if (now - this.lastZoneDamage > 1000) {
        this.player.health -= 5; this.lastZoneDamage = now;
        if (this.player.health <= 0) this.endGame();
      }
    }

    while (this.grassBlades.length < CONFIG.GRASS_BLADE_COUNT) {
      this.grassBlades.push(new GrassBlade(
        Math.random() * this.mapW,
        Math.random() * this.mapH,
        CONFIG.GRASS_LENGTH_MIN + Math.random() * (CONFIG.GRASS_LENGTH_MAX-CONFIG.GRASS_LENGTH_MIN),
        Math.random() * Math.PI
      ));
    }
  }

  draw() {
    const ctx = this.ctx;
    ctx.clearRect(0,0,CONFIG.VIEW_W,CONFIG.VIEW_H);
    ctx.save();
    ctx.translate(-this.viewX, -this.viewY);

    ctx.strokeStyle="#333";
    ctx.lineWidth=10;
    ctx.strokeRect(0,0,this.mapW,this.mapH);

    ctx.strokeStyle='lime'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(this.zone.x,this.zone.y,this.zone.radius,0,Math.PI*2); ctx.stroke();

    ctx.strokeStyle='green';
    for (let g of this.grassBlades) {
      ctx.beginPath(); ctx.moveTo(g.x,g.y);
      ctx.lineTo(g.x+Math.cos(g.angle)*g.length,g.y-Math.sin(g.angle)*g.length);
      ctx.stroke();
    }

    ctx.fillStyle=this.player.color;
    ctx.beginPath(); ctx.arc(this.player.x,this.player.y,this.player.size/2,0,Math.PI*2); ctx.fill();

    const w = this.weapons[this.currentWeapon];
    let angle = Math.atan2(this.pointerY + this.viewY - this.player.y,this.pointerX + this.viewX - this.player.x);
    if (w.type==='gun') {
      ctx.save(); ctx.translate(this.player.x,this.player.y); ctx.rotate(angle);
      ctx.fillStyle=w.color;
      ctx.fillRect(this.player.size/2, -w.gunWidth/2, w.gunLength, w.gunWidth);
      ctx.restore();
    }
    if (w.type === 'melee') {
      ctx.save();
      ctx.translate(this.player.x, this.player.y);
      ctx.rotate(angle);
      ctx.fillStyle = w.color;
      ctx.fillRect(this.player.size/2, -w.stickWidth/2, w.stickLength, w.stickWidth);
      ctx.beginPath();
      ctx.arc(this.player.size/2 + w.stickLength, 0, w.stickWidth/2, 0, Math.PI*2);
      ctx.fillStyle = "#7c5a27";
      ctx.fill();
      ctx.restore();
    }

    for (let b of this.bullets) {
      if (b.visible) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.shadowColor = 'white';
        ctx.shadowBlur = 16;
        ctx.fill();
        ctx.restore();
      }
    }

    for (let e of this.enemies){
      if (e.hidden) continue;
      ctx.save();
      ctx.translate(e.x, e.y);
      const speed = Math.hypot(e.vx, e.vy);
      if (speed > 2) {
        ctx.rotate(Math.sin(performance.now()/80+e.x+e.y)*0.08);
        ctx.scale(1 + Math.min(speed/10,0.16), 1 - Math.min(speed/14,0.09));
      }
      if (e.hitting) {
        let t = (Date.now() - e.hitAnimStart) / CONFIG.ENEMY_HIT_ANIMATION_TIME;
        t = clamp(t, 0, 1);
        ctx.save();
        ctx.globalAlpha = 0.45 + 0.55 * Math.sin(Math.PI * t);
        ctx.scale(1.01 + 0.3 * Math.sin(Math.PI * t), 1.01 - 0.15 * Math.sin(Math.PI * t));
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(0, 0, e.size/2+8, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      ctx.fillStyle=e.color;
      ctx.beginPath(); ctx.arc(0,0,e.size/2,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='red'; ctx.fillRect(-e.size/2, -e.size/2-10, e.size, 5);
      ctx.fillStyle='lime'; ctx.fillRect(-e.size/2, -e.size/2-10, e.size*(e.health/e.maxHealth), 5);
      ctx.restore();
    }

    for (let crate of this.crates) {
      if (crate.opened || crate.hidden) continue;
      ctx.save();
      ctx.translate(crate.x, crate.y);
      ctx.fillStyle = crate.type === 'rifle' ? '#6077f2' : '#d2a84c';
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.rect(-crate.size/2, -crate.size/2, crate.size, crate.size);
      ctx.fill();
      ctx.stroke();
      ctx.font = "15px Verdana";
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(crate.type === 'rifle' ? "R" : "P", 0, 0);
      ctx.restore();

      if (
        Math.hypot(this.player.x-crate.x, this.player.y-crate.y) < this.player.size/2 + crate.size/2
        && !crate.opened
      ) {
        ctx.save();
        ctx.font = "18px Verdana";
        ctx.fillStyle = "#ffb";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        
        // Check if mobile controls are active (either small screen OR manually toggled)
        const isMobileControlActive = window.innerWidth <= 820 || document.getElementById('game-container').classList.contains('mobile-mode');

        if (!isMobileControlActive) {
           ctx.fillText("Press E to open", crate.x, crate.y+crate.size/2+5);
        } else {
           ctx.fillText("Press Action button", crate.x, crate.y+crate.size/2+5);
        }
        ctx.restore();
      }
    }

    ctx.restore();

    ctx.fillStyle='white'; ctx.font='20px Verdana';
    ctx.fillText(`HP: ${this.player.health}`,10,20);
    ctx.fillText(`Kills: ${this.kills}`,10,45);
    ctx.fillText(`Zone: ${this.zone.radius.toFixed(1)}`,10,70);
    ctx.fillText(`${this.weapons[this.currentWeapon].name}`,10,95);
    if (this.weapons[this.currentWeapon].type==='gun') {
      let weapon = this.weapons[this.currentWeapon];
      if (this.reloading){
        ctx.fillText(`Reloading...`,10,120);
        let barX = 10, barY = 145, barW = 120, barH = 16;
        ctx.fillStyle = '#222';
        ctx.fillRect(barX, barY, barW, barH);
        ctx.fillStyle = '#fff';
        let reloadPct = 1 - Math.max(this.reloadRemaining,0)/weapon.reloadTime;
        ctx.fillRect(barX, barY, barW*reloadPct, barH);
        ctx.strokeStyle = '#eee';
        ctx.strokeRect(barX, barY, barW, barH);
        ctx.fillStyle = '#fff';
        ctx.font = '16px Verdana';
        ctx.fillText(`${(this.reloadRemaining/1000).toFixed(2)}s`, barX+barW+8, barY+barH-3);
      } else if (weapon.totalAmmo > 0) {
        ctx.fillText(`Ammo: ${weapon.ammo}/${weapon.magSize} | Reserve: ${weapon.totalAmmo}`,10,120);
      } else {
        ctx.fillText(`Ammo: ${weapon.ammo}/${weapon.magSize} | Reserve: 0`,10,120);
        ctx.fillStyle = '#ffb';
        ctx.font = '18px Verdana';
        ctx.fillText("Find crates for more ammo!",10,170);
      }
    }
    if (!this.running && this.player.health <= 0) {
      ctx.fillStyle='white'; ctx.font='50px Verdana';
      ctx.fillText("Game Over",220,300);
      ctx.fillText("Total Kills: "+this.kills,220,360);
    }
  }

  gameLoop() {
    if (!this.running) return;
    const now = performance.now();
    const delta = clamp((now - this.lastFrameTime), 0, 50);
    this.lastFrameTime = now;
    if (!this.paused) {
      this.update(delta);
      this.draw();
      if (this.player.health > 0) {
        requestAnimationFrame(()=>this.gameLoop());
      }
    }
  }
}

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const pauseBtn = document.getElementById('pauseBtn');
const mobileToggleBtn = document.getElementById('mobileToggleBtn');
const fireBtn = document.getElementById('fire-button');
const switchBtn = document.getElementById('weapon-switch-btn');
const reloadBtn = document.getElementById('reload-btn');
const actionBtn = document.getElementById('action-btn');
const joystickContainer = document.getElementById('joystick-container');
const joystickHandle = document.getElementById('joystick-handle');
const gameContainer = document.getElementById('game-container');
let game = new Game(canvas, ctx);

// --- Button Handlers ---

pauseBtn.addEventListener('click', () => {
  game.paused = !game.paused;
  pauseBtn.textContent = game.paused ? '▶️' : '⏸️';
  if (game.paused) game.pause();
  else game.resume();
});

// NEW: Mobile Toggle Button Logic
mobileToggleBtn.addEventListener('click', () => {
    const isMobileMode = gameContainer.classList.toggle('mobile-mode');
    mobileToggleBtn.textContent = isMobileMode ? 'Mobile Off' : 'Mobile On';
});

// Helper function to handle button presses for both touch and mouse
function handleButtonPress(btn) {
  if (game.paused) return;
  switch (btn) {
    case 'fire':
      game.touchFireActive = true;
      game.attack();
      break;
    case 'switch':
      game.currentWeapon = (game.currentWeapon + 1) % game.weapons.length;
      break;
    case 'reload':
      if (game.reloading) return;
      const weapon = game.weapons[game.currentWeapon];
      if (weapon.type === 'gun' && weapon.ammo < weapon.magSize && weapon.totalAmmo > 0) {
        game.reloading = true;
        game.reloadRemaining = weapon.reloadTime;
        game.reloadStartTime = Date.now();
      }
      break;
    case 'action':
      game.openCrateRequested = true;
      break;
  }
}

// Helper function to handle button releases (mainly for auto-fire)
function handleButtonRelease(btn) {
  if (btn === 'fire') {
    game.touchFireActive = false;
  }
}

// --- Fire Button (Touch & Mouse) ---
// Touch
fireBtn.addEventListener('touchstart', e => { e.preventDefault(); handleButtonPress('fire'); }, { passive: false });
fireBtn.addEventListener('touchend', () => { handleButtonRelease('fire'); });
// Mouse emulation (NEW)
fireBtn.addEventListener('mousedown', e => { e.preventDefault(); handleButtonPress('fire'); });
fireBtn.addEventListener('mouseup', () => { handleButtonRelease('fire'); });

// --- Weapon Switch Button (Touch & Mouse) ---
// Touch is handled by 'click' which triggers after touchend
switchBtn.addEventListener('click', () => { handleButtonPress('switch'); });

// --- Reload Button (Touch & Mouse) ---
// Touch is handled by 'click' which triggers after touchend
reloadBtn.addEventListener('click', () => { handleButtonPress('reload'); });

// --- Action/Open Crate Button (Touch & Mouse) ---
// Touch is handled by 'click' which triggers after touchend
actionBtn.addEventListener('click', () => { handleButtonPress('action'); });


// --- Desktop Input ---
document.addEventListener('keydown', e => {
  if (game.paused) return;
  game.keys[e.key] = true;
  if (!game.reloading) {
    if (e.key === '1') game.currentWeapon = 0;
    if (e.key === '2') game.currentWeapon = 1;
    if (e.key === '3') game.currentWeapon = 2;
  }
  if (e.key === 'e' || e.key === 'E') {
    game.openCrateRequested = true;
  }
});
document.addEventListener('keyup', e => {
  if (game.paused) return;
  game.keys[e.key] = false;
});

// Canvas Mouse Input for aiming/firing
canvas.addEventListener("mousemove", e => {
  if (game.paused) return;
  const rect = canvas.getBoundingClientRect();
  game.pointerX = e.clientX - rect.left;
  game.pointerY = e.clientY - rect.top;
});
canvas.addEventListener("mousedown", e => {
  if (game.paused) return;
  game.mouseDown = true; // Use game.mouseDown for desktop fire
  game.attack();
});
canvas.addEventListener("mouseup", () => { game.mouseDown = false; });


// --- Joystick Functions ---
const MAX_JOYSTICK_DIST = 40;

function updateAimFromTouch(touch) {
    if (!touch || game.paused) return;
    const rect = canvas.getBoundingClientRect();
    game.pointerX = touch.clientX - rect.left;
    game.pointerY = touch.clientY - rect.top;
}

function getCenterAndCurrent(e) {
  const rect = joystickContainer.getBoundingClientRect();
  const centerX = rect.width / 2;
  const centerY = rect.height / 2;
  let currentX, currentY;
  
  if (e.touches && e.touches.length > 0) {
    // Touch event
    let touch;
    for (let i = 0; i < e.touches.length; i++) {
        const t = e.touches[i];
        if (t.target === joystickContainer || t.target === joystickHandle) {
            touch = t;
            break;
        }
    }
    if (!touch) return null;
    currentX = touch.clientX - rect.left;
    currentY = touch.clientY - rect.top;
  } else {
    // Mouse event
    currentX = e.clientX - rect.left;
    currentY = e.clientY - rect.top;
  }
  
  return { centerX, centerY, currentX, currentY };
}

function handleJoystickMove(e) {
  const coords = getCenterAndCurrent(e);
  if (!coords) return;
  const { centerX, centerY, currentX, currentY } = coords;

  const dx = currentX - centerX;
  const dy = currentY - centerY;
  const dist = Math.hypot(dx, dy);
  const angle = Math.atan2(dy, dx);
  
  const clampDist = Math.min(dist, MAX_JOYSTICK_DIST);
  
  const finalX = Math.cos(angle) * clampDist;
  const finalY = Math.sin(angle) * clampDist;
  
  // Update game state for movement
  game.touchMoveCurrent.x = currentX;
  game.touchMoveCurrent.y = currentY;
  
  // Update handle position
  joystickHandle.style.transform = `translate(${finalX}px, ${finalY}px)`;
}

function handleJoystickStart(e) {
    if (game.paused) return;
    e.preventDefault();
    game.touchMoveActive = true;
    
    // Determine the starting point (touch or mouse)
    const rect = joystickContainer.getBoundingClientRect();
    if (e.touches && e.touches.length > 0) {
        game.touchMoveStart.x = e.touches[0].clientX - rect.left;
        game.touchMoveStart.y = e.touches[0].clientY - rect.top;
    } else {
        game.isDesktopClickActive = true; // NEW: Flag for mouse emulation
        game.touchMoveStart.x = e.clientX - rect.left;
        game.touchMoveStart.y = e.clientY - rect.top;
    }

    handleJoystickMove(e);
}

function handleJoystickEnd(e) {
    // If it's a touchend event, check for remaining touches
    if (e.type === 'touchend') {
      let activeJoystickTouch = false;
      for (let i = 0; i < e.touches.length; i++) {
        if (e.touches[i].target === joystickContainer || e.touches[i].target === joystickHandle) {
          activeJoystickTouch = true;
          break;
        }
      }
      if (activeJoystickTouch) return; // Keep joystick active if another touch is still holding it down
    }

    // If it's a mouseup event, check the flag
    if (e.type === 'mouseup' && !game.isDesktopClickActive) return;
    
    // Reset state
    game.touchMoveActive = false;
    game.isDesktopClickActive = false; // NEW: Reset mouse flag
    joystickHandle.style.transform = `translate(0px, 0px)`;
}


// --- Joystick Event Listeners (Combined Touch & Mouse) ---

// Start (Touch & Mouse)
joystickContainer.addEventListener('touchstart', handleJoystickStart, { passive: false });
joystickContainer.addEventListener('mousedown', handleJoystickStart);

// Move (Touch & Mouse)
joystickContainer.addEventListener('touchmove', e => { e.preventDefault(); handleJoystickMove(e); }, { passive: false });
// NOTE: Mouse movement needs to be tracked on the whole document when the click is held down
document.addEventListener('mousemove', e => { 
    if (game.touchMoveActive && game.isDesktopClickActive) {
      handleJoystickMove(e);
    }
});

// End (Touch & Mouse)
joystickContainer.addEventListener('touchend', handleJoystickEnd);
document.addEventListener('mouseup', handleJoystickEnd);


// --- Canvas Aiming (Touch only - Mouse is handled by canvas listeners) ---

canvas.addEventListener('touchstart', e => {
    if (game.paused) return;
    e.preventDefault();
    
    // Use the first touch that is NOT a control to set the aiming point
    let aimTouch = null;
    for (let i = 0; i < e.touches.length; i++) {
        const t = e.touches[i];
        const target = t.target;
        if (!target.classList.contains('touch-control')) {
            aimTouch = t;
            break;
        }
    }
    
    if (aimTouch) {
        updateAimFromTouch(aimTouch);
    } 

    // Two-finger touch to fire (simple two-finger gesture)
    if (e.touches.length === 2 && !game.touchMoveActive) {
      game.touchFireActive = true;
      game.attack();
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    if (game.paused) return;
    e.preventDefault();

    // Aiming update from the touch that is NOT a control
    let aimTouch = null;
    for (let i = 0; i < e.touches.length; i++) {
        const t = e.touches[i];
        const target = t.target;
        if (!target.classList.contains('touch-control')) {
            aimTouch = t;
            break;
        }
    }
    if (aimTouch) {
      updateAimFromTouch(aimTouch);
    }
    
}, { passive: false });

canvas.addEventListener('touchend', e => {
    if (game.paused) return;
    // Check if a two-finger fire gesture ended
    if (game.touchFireActive && e.touches.length < 2) {
      game.touchFireActive = false;
    }
});


game.start();

</script>
</body>
</html>
